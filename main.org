#+title: Equation-of-motion coupled-cluster for defects in solids
#+author: Alejandro Gallo
#+date: Toulouse, 22-01-2021 
#+latex_header: \usepackage{xcolor}
#+OPTIONS: H:2 toc:t t:nil
#+OPTIONS: TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc

* Solid state in a nutshell
** One Hydrogen atom
Adapted partially from [[cite:SolidsAndSurf1988Hoffmann][Hoffmann 1988]]

\begin{equation*}
\phi^\mathrm{1s}
\end{equation*}

#+call: make-hchain("-n 1 -k 0")

#+RESULTS:
[[file:figures/hchain-base32-FVXCAMJAFVVSAMAK.png]]


** Two Hydrogen atoms (bonding)
   
\begin{equation*}
\phi^{\mathrm{1s}}_{\color{red} 0} + \phi^{\mathrm{1s}}_{\color{red} 1}
= e^{i {\color{red} 0} a k } \phi^{\mathrm{1s}}_{\color{red} 0}
+ e^{i {\color{red} 1} a k } \phi^{\mathrm{1s}}_{\color{red} 1}
\quad k = 0
\end{equation*}

#+call: make-hchain("-n 2 -k 0")

#+RESULTS:
[[file:figures/hchain-base32-FVXCAMRAFVVSAMAK.png]]

** Two Hydrogen atoms (\textcolor{red}{anti}-bonding)

\begin{equation*}
\phi^{\mathrm{1s}}_{\color{red} 0} - \phi^{\mathrm{1s}}_{\color{red} 1}
= e^{i {\color{red} 0} a k } \phi^{\mathrm{1s}}_{\color{red} 0}
- e^{i {\color{red} 1} a k } \phi^{\mathrm{1s}}_{\color{red} 1}
\quad k = \frac{\pi}{a}
\end{equation*}

#+call: make-hchain("-n 2 -k 1")

#+RESULTS:
[[file:figures/hchain-base32-FVXCAMRAFVVSAMIK.png]]

** 6 Hydrogen atoms (bonding)
\begin{equation*}
  \sum_{\color{red} j} \phi^{\mathrm{1s}}_{\color{red} j}
= \sum_{\color{red} j} e^{i{\color{red} j} a k }\phi^{\mathrm{1s}}_{\color{red} j}
\quad k = 0
\end{equation*}

#+call: make-hchain("-n 6 -k 0")

#+RESULTS:
[[file:figures/hchain-base32-FVXCANRAFVVSAMAK.png]]

** 6 Hydrogen atoms (\textcolor{red}{anti}-bonding)

\begin{equation*}
  \sum_{\color{red} j} (-1)^{\color{red} j} \phi^{\mathrm{1s}}_{\color{red} j}
= \sum_{\color{red} j} e^{i{\color{red} j} a k }\phi^{\mathrm{1s}}_{\color{red} j}
\quad k = \frac{\pi}{a}
\end{equation*}

#+call: make-hchain("-n 6 -k 3")

#+RESULTS:
[[file:figures/hchain-base32-FVXCANRAFVVSAMYK.png]]
** Bloch's theorem: motivation

*** Column 1
    :properties:
      :beamer_col: 0.7
    :end:
    
- We want to model a solid
- Edge effects can be neglected
  - In the thermodynamical limit, the ``molecule'' is efectively
    infinite.
- Periodic boundary conditions \Leftarrow Finite systems
  #+call: make-hchain("-n 6 -k 3 --circle")

  #+attr_latex: :width 0.5\textwidth
  #+RESULTS:
  [[file:figures/hchain-base32-FVXCANRAFVVSAMZAFUWWG2LSMNWGKCQ.png]]
- Translational invariance \Rightarrow
  How do the /symmetry adapted/ molecular orbitals look like?


*** Column 2
    :properties:
    :beamer_col: 0.3
    :end:

#+call: make-hchain("-n 6 -k 3")

#+attr_latex: :options angle=90
#+attr_latex: :height 0.5\textheight
#+RESULTS:
[[file:figures/hchain-base32-FVXCANRAFVVSAMYK.png]]

** Bloch's theorem: stage

*** Column 1
    :properties:
    :beamer_col: 0.7
    :end:

- Bravais lattice $\mathcal{B} = \{ R \}$
- Translation operator $\hat T(R) = e^{i R \cdot \hat k }$
- Group of translation is commutative
  - one dimensional irreps!
  - orbitals are eigenvectors of $\hat T (R)$ for all $R\in \mathcal{B}$
  - Bloch's theorem:
    \[
       \hat T(R) \psi = e^{i R \cdot k} \psi
       \quad k \in \mathbb{R}^3
    \]
  - Bloch orbitals $\{ \psi_k \}$ (symmetry adapted)



*** Column 2
    :properties:
    :beamer_col: 0.3
    :end:

#+headers: :cache yes
#+begin_src asymptote :file figures/simple-lattice.pdf
unitsize(1cm);

int n = 4;

for (int i=0; i<n; ++i) {
for (int j=0; j<n; ++j) {
  dot((i,j));
}
}

draw((0, 0) -- (1, 3), black, Arrow);
draw((0, 0) -- (3, 1), black, Arrow);
#+end_src

#+attr_latex: :height 1\textwidth
#+attr_org: :width 300px
#+RESULTS[119c881b4f9b3a606916564b00b3cb45ac73d321]:
[[file:figures/simple-lattice.pdf]]



** Band structures: Hydrogen chain

Linear combination of atomic orbitals:
\begin{equation*}
\psi_{k, \mathrm{1s}}
  = \sum_{\color{red} j} e^{ik {\color{red} j} a } \phi^{\mathrm{1s}}_{\color{red} j}
\end{equation*}

#+beamer: \only<1>{
#+call: make-hchain("-n 1 -k 0 --ny 0     ")

#+RESULTS:
[[file:figures/hchain-base32-FVXCAMJAFVVSAMBAFUWW46JAGAQCAIBAEAFA.png]]

#+beamer: }
#+beamer: \only<2>{
#+call: make-hchain("-n 2 -k 0 --ny 0     ")

#+RESULTS:
[[file:figures/hchain-base32-FVXCAMRAFVVSAMBAFUWW46JAGAQCAIBAEAFA.png]]

#+beamer: }
#+beamer: \only<3>{
#+call: make-hchain("-n 3 -k 0 --ny 0     ")

#+RESULTS:
[[file:figures/hchain-base32-FVXCAMZAFVVSAMBAFUWW46JAGAQCAIBAEAFA.png]]

#+beamer: }
#+beamer: \only<4>{
#+call: make-hchain("-n 4 -k 0 --ny 0     ")

#+RESULTS:
[[file:figures/hchain-base32-FVXCANBAFVVSAMBAFUWW46JAGAQCAIBAEAFA.png]]

#+beamer: }
#+beamer: \only<5>{
#+caption: asdf
#+call: make-hchain("-n 5 -k 0 --ny 0     ")

#+RESULTS:
[[file:figures/hchain-base32-FVXCANJAFVVSAMBAFUWW46JAGAQCAIBAEAFA.png]]

#+beamer: }


** Defects and super-cells

*** Column 1
    :properties:
    :beamer_col: 0.5
    :end:
    



\pause
- unit cell with a defect
#+headers: :var n=2 repeat=1
#+name: make-defect-in-lattice
#+begin_src asymptote :file figures/defect-images.pdf
unitsize(1cm);

for (int j=0; j<n; ++j) {
for (int i=0; i<n; ++i) {
  dot((i,j));
  if (i > 0)                  draw((i,j) -- (i-1, j));
  if (j > 0)                  draw((i,j) -- (i, j-1));
  if (repeat == 1)
  if (i < n - 1 && j < n - 1) dot((i+.5, j + .5), red);
}
}

if (repeat == 0) dot((n / 2 - 0.5, n/2 - 0.5), red);

#+end_src

#+attr_org: :width 300px
#+attr_latex: :width 0.2\textwidth
#+RESULTS: make-defect-in-lattice
[[file:figures/defect-images.pdf]]

\pause
- repeating it
#+call: make-defect-in-lattice(n=6) :file figures/defect-images-6.pdf

#+attr_org: :width 300px
#+attr_latex: :width 0.8\textwidth
#+RESULTS:
[[file:figures/defect-images-6.pdf]]

*** Column 2
    :properties:
    :beamer_col: 0.5
    :end:

\pause
- Supercell
#+call: make-defect-in-lattice(n=6, repeat=0) :file figures/defect-images-6-no-repeat.pdf

#+attr_org: :width 300px
#+attr_latex: :width 1\textwidth
#+RESULTS:
[[file:figures/defect-images-6-no-repeat.pdf]]

** Quantum chemistry \approx \Gamma-point
* Ground-state Coupled-Cluster
** Exponential \textit{Ansatz}
** Size-extensivity and size-consistency for solids

* Equation-of-motion Coupled-cluster
** In a nutshell?
** Why not just CI?
** Connection to linear response CC

* CC4S
** Pseudo-potentials
** VASP
** Our interface
** Tensor frameworks

* \(F\)-centers




* Summary
** Summary
** Bibliography
bibliographystyle:unsrt
bibliography:main.bib,~/Documents/papers/bibfile.bib


** Thank you

#+begin_center
Thank you!
#+end_center

[[file:figures/group2019.png]]

* Scripts                                                          :noexport:
  :properties:
    :header-args: :comments both
    :header-args:python: :tangle-mode (identity #o777)
    :header-args:python+: :shebang #!/usr/bin/env python
  :end:
** Makefile

#+headers: :tangle Makefile
#+begin_src makefile
define PYTHON
nix-shell --run "python $(1)"
endef

define PIP
nix-shell --run "pip $(1)"
endef
#+end_src

** Nix shell

If you used the nix package manager you can use the supplied
shell to compile the examples.

#+begin_src nix :tangle shell.nix

{ pkgs ? import <nixpkgs> {} }:
let
    chbench = import ./nix/chbench.nix {};
    my-python-packages = pypkgs: with pypkgs; [
      matplotlib
      numpy
      pip
      setuptools
      chbench
      tkinter
      virtualenv
    ];
    my-python = pkgs.python37.withPackages my-python-packages;
in
pkgs.mkShell rec {
  buildInputs = with pkgs; [
    my-python
    stdenv.cc.cc.lib
  ];
  shellHook = "
  LD_LIBRARY_PATH=${pkgs.stdenv.cc.cc.lib}/lib:$LD_LIBRARY_PATH;
  ";
}

#+end_src

and we need for chbench a nix package
#+headers: :tangle nix/chbench.nix :mkdirp yes
#+begin_src nix

{pkgs ? import <nixpkgs> {}}:

with pkgs.python37Packages;

buildPythonPackage rec {
  name = "chbench";
  src = pkgs.fetchFromGitHub { owner = "alejandrogallo";
                               repo = "chbench";
                               rev = "f0d789d85fbaae831f1f9747d201ff4360d43e7e";
                               sha256 = "01yjsqlgjhngzgy17kxbx3z4ywgcnjfkqx603hqg8c7fk4rxriam";
                             };
  propagatedBuildInputs = [ pytest numpy ase matplotlib ];
}

#+end_src



** H Chain
   :properties:
    :header-args+: :tangle scripts/make-hchain.py
   :end:

#+begin_src python
import numpy as np
import matplotlib.pyplot as plt
from chbench.basis import *
from chbench.visualization import *
import chbench.parser.basis
import sys
import argparse

plt.rcParams['xtick.bottom'] = False
plt.rcParams['xtick.labelbottom'] = False
plt.rcParams['ytick.left'] = False
plt.rcParams['ytick.labelleft'] = False
plt.gca().set_aspect('equal')

parser = argparse.ArgumentParser("")
parser.add_argument("-o", help="Output file", type=str)
parser.add_argument("-n", help="Number of hydrogens", type=int)
parser.add_argument("-k", help="K", type=str)
parser.add_argument("-a", help="Hidrogen bond length", type=float, default=0.74)
parser.add_argument("--alpha", help="Alpha of orbital", type=float, default=2)
parser.add_argument("--nx", help="nx of gaussian orbital", type=int, default=0)
parser.add_argument("--ny", help="ny of gaussian orbital", type=int, default=0)
parser.add_argument("--nz", help="nz of gaussian orbital", type=int, default=0)
parser.add_argument("--circle",
                    help="nz of gaussian orbital", action="store_true")
args = parser.parse_args()

N = args.n
ki = float(eval(args.k))

nx = 400
ny = nx

if args.circle:
    hydrogens = np.array([[args.a * np.sin(2*np.pi / N * i),
                           args.a * np.cos(2*np.pi / N * i),
                           0] for i in range(N)])
else:
    hydrogens = np.array([[i * args.a, 0, 0] for i in range(N)])

max_x = np.max(hydrogens[:,0])
max_y = np.max(hydrogens[:,1])
min_x = np.min(hydrogens[:,0])
min_y = np.min(hydrogens[:,1])

pad = 1
xlims = [min_x - pad, max_x + pad]
ylims = [min_y - pad, max_y + pad]

#+end_src

and we put the modulator function which is just

$$
e^{i x k_i \frac{2 \pi}{aN}}
$$

#+begin_src python
def modulator(x, ki):
    return np.exp(np.complex(0,1) * x * ki * 2 * np.pi / (args.a * N))

s = GaussianOrbital(args.alpha, args.alpha, args.alpha,
                    args.nx, args.ny, args.nz,
                    [0, 0, 0])


print('Building new coeffs')
coefficients = [modulator(i * args.a, ki) for i in range(N)]

print('Building new gaussians')
gaussians = [s.translate(h) for h in hydrogens]

print('Building new cgaussians')
b = ContractedGaussian(coefficients, gaussians)

print('Building new surface')
surface = plot_gaussian_xy(xlims,
                           ylims,
                           nx,
                           ny,
                           lambda x,y,z: np.real(b(x,y,z)),
                           z=0,
                           fill=True)

for i, g in enumerate(gaussians):
    newg = g * coefficients[i]
    gxlims = [i * args.a -1 , i * args.a +1] #[g.center[0] - 1, g.center[0] + 1]
    plot_gaussian_xy(xlims, ylims,
                     nx, ny,
                     lambda x,y,z: np.real(newg(x,y,z)),
                     z=0,
                     fill=False,
                     alpha=0.1, colors='k')

plt.scatter(hydrogens[:,0], hydrogens[:,1], color='r')

#plt.xlabel(r'$k = \frac{{2\pi}}{{aN}}{k}$'.format(k=args.k))

plt.gcf().tight_layout()
plt.savefig(args.o)
print(args.o)
#+end_src

and for the makefile we need to do
#+headers: :tangle Makefile
#+begin_src makefile

HCHAIN_FLAGS ?= -n 5 -k 0

define hchain_hash
$(shell echo "$(HCHAIN_FLAGS)" | base32 -w0  | tr -d '=')
endef

hchain: figures/hchain-base32-$(call hchain_hash).png scripts/make-hchain.py
	@printf $<

figures/hchain-base32-%.png: scripts/make-hchain.py
	$(call PYTHON,./$< $(shell base32 -id <<< $*) -o $@)

.PHONY: hchain

#+end_src

and the script for making
#+name: make-hchain
#+headers: :var flags="-n 1 -k 0" :tangle no
#+begin_src sh :results value file :exports results
make hchain HCHAIN_FLAGS="$flags" | tail -1
#+end_src
